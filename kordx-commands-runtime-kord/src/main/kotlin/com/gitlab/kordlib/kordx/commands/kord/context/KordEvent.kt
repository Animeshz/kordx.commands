package com.gitlab.kordlib.kordx.commands.kord.context

import com.gitlab.kordlib.core.behavior.channel.createEmbed
import com.gitlab.kordlib.core.behavior.channel.createMessage
import com.gitlab.kordlib.core.entity.Message
import com.gitlab.kordlib.core.event.message.MessageCreateEvent
import com.gitlab.kordlib.kordx.commands.argument.Argument
import com.gitlab.kordlib.kordx.commands.argument.Result
import com.gitlab.kordlib.rest.builder.message.EmbedBuilder
import com.gitlab.kordlib.rest.builder.message.MessageCreateBuilder
import kotlinx.coroutines.flow.*


interface KordEvent {
    val event: MessageCreateEvent
    val kord get() = event.kord
    val message get() = event.message
    val author get() = message.author!!
    val channel get() = message.channel
    val guild get() = message.guild

    suspend fun respond(text: String): Message {
        return message.channel.createMessage(text)
    }

    /**
     *  Suspends until the user invoking this command enters a message in this channel that's accepted by the given [argument].
     *  Note that this function doesn't return until a valid value is entered, which might negatively impact user experience.
     *  If this is a concern, consider using the method overload that accepts escape words.
     *  @param filter an additional filter for generated values, ignoring all values that return false.
     *  @return an item [T] generated by the [argument]
     */
    suspend fun <T> read(
            argument: Argument<T, MessageCreateEvent>,
            filter: suspend (T) -> Boolean = { true }
    ): T = kord.events.filterIsInstance<MessageCreateEvent>()
            .filter { it.message.author?.id == message.author!!.id }
            .filter { it.message.channel.id == channel.id }
            .map { argument.parse(it.message.content.split(" "), 0, it) }
            .onEach { if (it is Result.Failure) respond(it.reason) }
            .filterIsInstance<Result.Success<T>>()
            .map { it.item }
            .filter(filter)
            .take(1)
            .single()

    /**
     *  Suspends until the user invoking this command enters a message in this channel that's accepted by the given [argument].
     *  @param filter an additional filter for generated values, ignoring all values that return false.
     *  @param escape a set of words that'll stop this function from taking input and return with null.
     *  @return an item [T] generated by the [argument]
     */
    suspend fun <T : Any> read(
            argument: Argument<T, MessageCreateEvent>,
            escape: String,
            filter: suspend (T) -> Boolean = { true }
    ): T? = kord.events.filterIsInstance<MessageCreateEvent>()
            .filter { it.message.author?.id == message.author!!.id }
            .filter { it.message.channel.id == channel.id }
            .takeWhile { it.message.content == escape }
            .map { argument.parse(it.message.content.split(" "), 0, it) }
            .onEach { if (it is Result.Failure) respond(it.reason) }
            .filterIsInstance<Result.Success<T>>()
            .map { it.item }
            .filter(filter)
            .take(1)
            .singleOrNull()

    companion object {
        operator fun invoke(event: MessageCreateEvent) = object : KordEvent {
            override val event: MessageCreateEvent = event
        }
    }

}

suspend inline fun KordEvent.respond(builder: MessageCreateBuilder.() -> Unit): Message {
    return message.channel.createMessage(builder)
}

suspend inline fun KordEvent.respondEmbed(builder: EmbedBuilder.() -> Unit): Message {
    return message.channel.createEmbed(builder)
}
