package com.gitlab.kordlib.kordx.commands.kord.context

import com.gitlab.kordlib.core.Kord
import com.gitlab.kordlib.core.KordObject
import com.gitlab.kordlib.core.behavior.channel.createEmbed
import com.gitlab.kordlib.core.behavior.channel.createMessage
import com.gitlab.kordlib.core.builder.message.EmbedBuilder
import com.gitlab.kordlib.core.builder.message.MessageCreateBuilder
import com.gitlab.kordlib.core.entity.Message
import com.gitlab.kordlib.core.event.message.MessageCreateEvent
import com.gitlab.kordlib.kordx.commands.argument.Argument
import com.gitlab.kordlib.kordx.commands.argument.Result
import com.gitlab.kordlib.kordx.commands.command.*
import com.gitlab.kordlib.kordx.commands.flow.ModuleGenerator
import com.gitlab.kordlib.kordx.commands.kord.module
import com.gitlab.kordlib.kordx.commands.pipe.PipeConfig
import com.gitlab.kordlib.kordx.commands.pipe.Prefix
import kotlinx.coroutines.flow.*
import java.time.Duration
import java.time.Instant


data class KordEvent(
        val event: MessageCreateEvent,
        override val command: Command<*>
) : EventContext, KordObject by event.message {
    override val module get() = command.module
    val message get() = event.message
    val author get() = message.author!!
    val channel get() = message.channel
    val guild get() = message.guild

    override suspend fun respond(text: String): Message {
        return message.channel.createMessage(text)
    }

    suspend inline fun respond(builder: MessageCreateBuilder.() -> Unit): Message {
        return message.channel.createMessage(builder)
    }

    suspend inline fun respondEmbed(builder: EmbedBuilder.() -> Unit): Message {
        return message.channel.createEmbed(builder)
    }

    /**
     *  Suspends until the user invoking this command enters a message in this channel that's accepted by the given [argument].
     *  @param filter an additional filter for generated values, ignoring all values that return false.
     *  @return an item [T] generated by the [argument]
     */
    suspend fun <T : Any> read(
            argument: Argument<T, MessageCreateEvent>,
            filter: suspend (T) -> Boolean = { true }
    ): T = kord.events.filterIsInstance<MessageCreateEvent>()
            .filter { it.message.author?.id == message.author!!.id }
            .filter { it.message.channel.id == channel.id }
            .map { argument.parse(it.message.content.split(" "), 0, it) }
            .onEach { if (it is Result.Failure) respond(it.reason) }
            .filterIsInstance<Result.Success<T>>()
            .map { it.item }
            .filter(filter)
            .take(1)
            .single()

}
