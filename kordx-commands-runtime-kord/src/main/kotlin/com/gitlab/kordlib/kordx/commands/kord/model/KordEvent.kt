package com.gitlab.kordlib.kordx.commands.kord.model

import com.gitlab.kordlib.core.behavior.channel.createEmbed
import com.gitlab.kordlib.core.behavior.channel.createMessage
import com.gitlab.kordlib.core.entity.Message
import com.gitlab.kordlib.core.event.message.MessageCreateEvent
import com.gitlab.kordlib.kordx.commands.argument.Argument
import com.gitlab.kordlib.kordx.commands.argument.result.ArgumentResult
import com.gitlab.kordlib.rest.builder.message.EmbedBuilder
import com.gitlab.kordlib.rest.builder.message.MessageCreateBuilder
import kotlinx.coroutines.flow.*

interface KordEvent {
    val event: MessageCreateEvent
    val kord get() = event.kord
    val message get() = event.message
    val author get() = message.author!!
    val channel get() = message.channel
    val guild get() = message.guild

    suspend fun respond(text: String): Message {
        return message.channel.createMessage(text)
    }

    /**
     *  Suspends until the user invoking this command enters a message in this channel that's accepted by the given [argument].
     *
     *  ```kotlin
     * command("ban")
     *     invoke {
     *         respond("Specify the user to ban")
     *         val member = read(MemberArgument, { it.message.content == "cancel" }) {
     *             if (it.id != kord.selfId) return@read true
     *
     *             respond("Can't ban myself.")
     *             false
     *         }
     *
     *         member.ban()
     *     }
     * }
     * ```
     * > This function doesn't return until a valid value is entered, which might negatively impact user experience.
     * > If this is a concern, consider using the method overload that accepts an escape filter.
     *
     *  @param filter an additional filter for generated values, ignoring all values that return false.
     *  @return an item [T] generated by the [argument]
     */
    suspend fun <T> read(
            argument: Argument<T, MessageCreateEvent>,
            filter: suspend (T) -> Boolean = { true }
    ): T = kord.events.filterIsInstance<MessageCreateEvent>()
            .filter { it.message.author?.id == message.author!!.id }
            .filter { it.message.channel.id == channel.id }
            .map { argument.parse(it.message.content.split(" "), 0, it) }
            .onEach { if (it is ArgumentResult.Failure) respond(it.reason) }
            .filterIsInstance<ArgumentResult.Success<T>>()
            .map { it.item }
            .filter(filter)
            .take(1)
            .single()

    /**
     *  Suspends until the user invoking this command enters a message in this channel that's accepted by the given [argument].
     *
     *  ```kotlin
     *  command("ban")
     *     invoke {
     *         respond("Specify the user to ban")
     *         val member = read(MemberArgument, { it.message.content == "cancel" }) {
     *             if (it.id != kord.selfId) return@read true
     *
     *             respond("Can't ban myself.")
     *             false
     *         }
     *
     *         member?.ban()
     *     }
     * }
     * ```
     *
     *  @param filter an additional filter for generated values, ignoring all values that return false.
     *  @param escape a filter that stops this function from taking input when returning true, resulting in this function returning null.
     *  @return an item [T] generated by the [argument]
     */
    suspend fun <T : Any> read(
            argument: Argument<T, MessageCreateEvent>,
            escape: suspend (MessageCreateEvent) -> Boolean,
            filter: suspend (T) -> Boolean = { true }
    ): T? = kord.events.filterIsInstance<MessageCreateEvent>()
            .filter { it.message.author?.id == message.author!!.id }
            .filter { it.message.channel.id == channel.id }
            .takeWhile { !escape(it) }
            .map { argument.parse(it.message.content.split(" "), 0, it) }
            .onEach { if (it is ArgumentResult.Failure) respond(it.reason) }
            .filterIsInstance<ArgumentResult.Success<T>>()
            .map { it.item }
            .filter(filter)
            .take(1)
            .singleOrNull()

    companion object {
        operator fun invoke(event: MessageCreateEvent) = object : KordEvent {
            override val event: MessageCreateEvent = event
        }
    }

}

suspend inline fun KordEvent.respond(builder: MessageCreateBuilder.() -> Unit): Message {
    return message.channel.createMessage(builder)
}

suspend inline fun KordEvent.respondEmbed(builder: EmbedBuilder.() -> Unit): Message {
    return message.channel.createEmbed(builder)
}
